Problem No:26

Link:https://leetcode.com/problems/longest-palindromic-substring/

Code:

class Solution {
    public int expand(String s,int left,int right){
        if(s==null && left>right) return 0;
        while(left>=0 && right<s.length() && s.charAt(left)==s.charAt(right)){
            left--;
            right++;
        }
        return right-left-1;
    }
    public String longestPalindrome(String s) {
        if(s==null && s.length()<1) return "";
        int start=0,end=0;
        for(int i=0;i<s.length();i++){
            int len1=expand(s,i,i);
            int len2=expand(s,i,i+1);
            int len=Math.max(len1,len2);
            if(len>end-start){
                start=i-((len-1)/2);
                end=i+(len/2);
            }
        }
        return s.substring(start,end+1);
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:27

Link:https://leetcode.com/problems/median-of-two-sorted-arrays/

Code:

class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] res=new int[nums1.length+nums2.length];
        int j=0;
        for(int i=0;i<nums1.length;i++)
        {
           res[j]=nums1[i];
           j++;
        }
        for(int i=0;i<nums2.length;i++)
        {
           res[j]=nums2[i];
           j++;
        }
        Arrays.sort(res);
        if(res.length%2!=0)
        {
            return (double)res[res.length/2];
        }
        
            int g=res[res.length/2]+res[(res.length/2)-1];
            double x=(double)g/2;
            return x;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:28

Link:https://leetcode.com/problems/regular-expression-matching/

Code:

class Solution {
    public boolean isMatch(String s, String p) {
        return s.matches("^" + p + "$");
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:29

Link:https://leetcode.com/problems/letter-combinations-of-a-phone-number/

Code:

class Solution {
public List<String> letterCombinations(String digits) {
    List<String> result = new ArrayList();
    if(digits.length()==0)
    return result;

    HashMap<String,String> map = new HashMap();
    map.put("2","abc"); map.put("3","def"); map.put("4","ghi"); map.put("5","jkl");
    map.put("6","mno"); map.put("7","pqrs"); map.put("8","tuv"); map.put("9","wxyz");

    Deque<String> a = new ArrayDeque();
    a.add("");

    for(int i=0; i<digits.length(); i++){
        String d = digits.substring(i,i+1);
        String fromMap = map.get(d);
        int n = a.size();
        for(int j =0; j<n ; j++){
            String pull = a.pollFirst();
            for(int k =0 ; k<fromMap.length();k++){
                String temp = pull.concat(fromMap.charAt(k)+"");
                a.add(temp);
            }
        }
    }
    while(!a.isEmpty()){
        result.add(a.poll());
    }
    return result;
	}
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:30

Link:https://leetcode.com/problems/longest-common-prefix/

Code:

class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String s1 = strs[0];
        String s2 = strs[strs.length-1];
        int index = 0;
        while(index < s1.length() && index < s2.length()){
            if(s1.charAt(index) == s2.charAt(index)){
                index++;
            } else {
                break;
            }
        }
        return s1.substring(0, index);
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:31

Link:https://leetcode.com/problems/valid-parentheses/

Code:

class Solution {
    public boolean isValid(String s) {
        Stack<Character> st = new Stack<>();
        for(char ch: s.toCharArray())
        {
            switch (ch)
            {
                case '(':
                case '{':
                case '[':
                    st.push(ch);
                    break;
                case ')':
                    if(st.isEmpty() || st.pop() != '(')
                    {
                        return false;
                    }
                    break;
                case '}':
                    if(st.isEmpty() || st.pop() != '{')
                    {
                        return false;
                    }
                    break;
                case ']':
                    if(st.isEmpty() || st.pop() != '[')
                    {
                        return false;
                    }
                    break;
            }
        }
        return st.isEmpty();     
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:32

Link:https://leetcode.com/problems/generate-parentheses/

Code:

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> list=new LinkedList<>();
        search("(",1,0,list,n);
        return list;
        
    }
    void search(String strs,int a,int b, List<String> list,int n){
        if(strs.length()==2*n){
            list.add(strs);
            return;
        }
        if(a<n) search(strs+"(",a+1,b,list,n);
        if(b<a) search(strs+")",a,b+1,list,n);
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:33

Link:https://leetcode.com/problems/merge-k-sorted-lists/

Code:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ArrayList<Integer> al = new ArrayList<Integer>();

        for (int i = 0; i < lists.length; i++) {
            while (lists[i] != null) {
                al.add(lists[i].val);
                lists[i] = lists[i].next;
            }

        }
        Collections.sort(al);

        ListNode head = new ListNode();
        ListNode ans = head;
        for (int i = 0; i < al.size(); i++) {
            head.next = new ListNode(al.get(i));
            head = head.next;

        }

        return ans.next;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:34

Link:https://leetcode.com/problems/swap-nodes-in-pairs/

Code:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode temp1=head;
        ListNode temp2=head.next;
        while(temp1!=null && temp2!=null){
            int t=temp2.val;
            temp2.val=temp1.val;
            temp1.val=t;
            if(temp2.next!=null){
                temp1=temp2.next;
            }
            else{
                return head;
            }
            if(temp1.next!=null){
                temp2=temp1.next;
            }
            else{
                return head;
            }
            
        }
        return head;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:35

Link:https://leetcode.com/problems/reverse-nodes-in-k-group/

Code:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head==null || k==1) return head;

        ListNode dummy = new ListNode();
        dummy.next = head;

        ListNode curr = dummy,nex = dummy,pre = dummy;

        int count=0;
        while(curr.next!=null){
            curr = curr.next;         
            count++;
        }

        while(count>=k){                 
            curr = pre.next;            
            nex = curr.next;           
            for(int i=1;i<k;i++){        
                curr.next = nex.next;
                nex.next = pre.next;
                pre.next = nex;
                nex = curr.next;
            }
            pre = curr;   
            count-=k;                   
        }
        return dummy.next;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:36

Link:https://leetcode.com/problems/remove-duplicates-from-sorted-array/

Code:

class Solution {
    public int removeDuplicates(int[] arr) {
        if(arr.length==0){
            return 0;
        }
        int cnt=1;
        for(int i = 0; i < arr.length - 1; i++) {
            if(arr[i]<arr[i + 1]){
              arr[cnt] = arr[i + 1];
              cnt++;
            }
        }
        return cnt;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:37

Link:https://leetcode.com/problems/remove-element/

Code:

class Solution {
    public int removeElement(int[] nums, int val) {
        
        int cnt=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=val){
                nums[cnt]=nums[i];
                cnt++;
            }
        }
        return cnt;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:38

Link:

Code:

class Solution {
    public int strStr(String h, String n) {
        int sw=n.length();
        for(int i=0;i<h.length()-sw+1;i++){
            String st=h.substring(i,i+sw);
            if(st.equals(n)){
                return i;
            }
        }
        return -1;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:39

Link:https://leetcode.com/problems/divide-two-integers/

Code:

class Solution {
    public int divide(int dividend, int divisor) {
        if(dividend==Integer.MIN_VALUE && divisor==-1)
            return Integer.MAX_VALUE;
        return (dividend/divisor);
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:40

Link:https://leetcode.com/problems/substring-with-concatenation-of-all-words/

Code:

class Solution {
    public List<Integer> findSubstring(String s, String[] w) {
        Map<String,Integer> nm=new LinkedHashMap<>();
        int a[]=new int[w.length];
        for(String p:w)
        {
            nm.put(p, nm.getOrDefault(p,0)+1);
        }
        int x=0;
        for(String p:nm.keySet())
        {
            a[x++]=nm.get(p);
        }
        int k=s.length(),c=w[0].length();
        List<Integer> f=new ArrayList<>();
        for(int i=0;i<=k-((w.length*c));i++)
        {
            StringBuilder kk=new StringBuilder();
            kk.append(s.substring(i,i+(w.length*c)));
            int j;
            for(j=i;j<i+(w.length*c);j+=c)
            {
                if(nm.containsKey(s.substring(j,j+c)))
                {
                    if(nm.get(s.substring(j,j+c))>0)
                    {
                        nm.put(s.substring(j,j+c), nm.get(s.substring(j,j+c))-1);
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }
            if(j==i+(w.length*c))
                f.add(i);
            j=0;
            for(String p:nm.keySet())
            {
                nm.put(p, a[j]);
                j++;
            }
        }
        return f;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:41

Link:https://leetcode.com/problems/next-permutation/

Code:

class Solution {
    public void nextPermutation(int[] nums) {
        int ind1=-1;
        int ind2=-1;
        for(int i=nums.length-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                ind1=i;
                break;
            }
        }
        if(ind1==-1){
            reverse(nums,0);
        }
        else{
            for(int i=nums.length-1;i>=0;i--){
                if(nums[i]>nums[ind1]){
                    ind2=i;
                    break;
                }
            }
            swap(nums,ind1,ind2);
            reverse(nums,ind1+1);
        }
    }
    void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
    void reverse(int[] nums,int start){
        int i=start;
        int j=nums.length-1;
        while(i<j){
            swap(nums,i,j);
            i++;
            j--;
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:42

Link:https://leetcode.com/problems/longest-valid-parentheses/

Code:

class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack();
        st.push(-1);
        int maxLen = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(s.charAt(i) == '(')
                st.push(i);
            else if(s.charAt(i) == ')')
            {    
                st.pop();
                if(st.empty())
                    st.push(i);
                else
                    maxLen = Math.max(maxLen, i - st.peek());     
            }
        }
        return maxLen;
    }
}


-----------------------------------------------------------------------------------------------------------------------------
Problem No:43

Link:https://leetcode.com/problems/search-in-rotated-sorted-array/

Code:

class Solution {
    public int search(int[] nums, int target) {
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target){
                return i;
            }
        }
        return -1;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:44

Link:https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

Code:

class Solution {
    public int[] searchRange(int[] nums, int target) {
        ArrayList<Integer>al=new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]==target){
                al.add(i);
                break;
            }
        }
        for(int i=nums.length-1;i>=0;i--){
            if(nums[i]==target){
                al.add(i);
                break;
            }
        }
        if(al.size()<1){
            al.add(-1);
            al.add(-1);
        }
        int k=0;
        int [] arr=new int [al.size()];
        for(int e:al){
            arr[k]=e;
            k++;
        }
        return arr;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:45

Link:https://leetcode.com/problems/search-insert-position/

Code:

class Solution {
    public int searchInsert(int[] nums, int target) {
        int i=0;
        for(i=0;i<nums.length;i++){
            if(nums[i]>=target){
                return i;
            }
        }
        return i;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:46

Link:https://leetcode.com/problems/valid-sudoku/

Code:

class Solution {
    public boolean isValidSudoku(char[][] board) {
    
        // Check rows
        for (int i = 0; i < 9; i++) {
            Set<Character> seen = new HashSet<>();
            for (int j = 0; j < 9; j++) {
                char digit = board[i][j];
                if (digit != '.' && seen.contains(digit)) {
                    return false;
                }
                seen.add(digit);
            }
        }

        // Check columns
        for (int j = 0; j < 9; j++) {
            Set<Character> seen = new HashSet<>();
            for (int i = 0; i < 9; i++) {
                char digit = board[i][j];
                if (digit != '.' && seen.contains(digit)) {
                    return false;
                }
                seen.add(digit);
            }
        }

        // Check sub-boxes
        for (int i = 0; i < 9; i += 3) {
            for (int j = 0; j < 9; j += 3) {
                Set<Character> seen = new HashSet<>();
                for (int k = 0; k < 9; k++) {
                    int row = i + k / 3;
                    int col = j + k % 3;
                    char digit = board[row][col];
                    if (digit != '.' && seen.contains(digit)) {
                        return false;
                    }
                    seen.add(digit);
                }
            }
        }
        return true;
    }

}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:47

Link:https://leetcode.com/problems/sudoku-solver/

Code:

class Solution {
    public void solveSudoku(char[][] board) {
        sodoku(board);
    }
    boolean sodoku(char board[][])
    {
        for(int i=0;i<9;i++)
        {
            for(int j=0;j<9;j++)
            {
                if(board[i][j] == '.')
                {
                    for(char c='1';c<='9';c++) //  Try 1 through 9.
                    {
                        if(isValid(board, i, j, c)) // checks the validity of that number.
                        {
                            board[i][j] = c; // //Put c for current cell.
                        
                            if(sodoku(board)) // //If it's the solution return true.
                            return true;
                            else
                            board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
     boolean isValid(char[][] board, int row, int col, char c){
        for(int i = 0; i < 9; i++) {
            if(board[i][col] != '.' && board[i][col] == c)
            return false; 
            if(board[row][i] != '.' && board[row][i] == c)
             return false; 
            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && 
board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) 
            return false; 
        }
        return true;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:48

Link:https://leetcode.com/problems/count-and-say/

Code:

class Solution {
    public String countAndSay(int n) {
        if(n == 1){
            return "1";
        }
        String st = "11";
        int j = 0;
        for(int i = 0;i<n-2;i++){
            int count = 1;
            String s = "";
            for( j = 0;j<st.length()-1;j++){
                if(st.charAt(j) == st.charAt(j+1)){
                    count++;
                }
                else{
                    s += Integer.toString(count);
                    s += st.charAt(j);
                    count = 1;
                }
            }
            s += Integer.toString(count);
            s += st.charAt(j);
            st = s;
        }
        return st;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:49

Link:https://leetcode.com/problems/combination-sum/

Code:

class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> arr = new ArrayList<>();
        func(candidates, arr, target, 0, new ArrayList<Integer>());
        return arr;
    }
    public void func(int[] candi, List<List<Integer>> arr, int target, int idx, List<Integer> temp) {
        if (idx==candi.length) {
            if (target==0) arr.add(new ArrayList<>(temp));
            return;
        }
        if (candi[idx]<=target) {
            temp.add(candi[idx]);
            func (candi, arr, target-candi[idx], idx, temp);
            temp.remove(temp.size()-1);
        }
        func (candi, arr, target, idx+1, temp);
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:50

Link:https://leetcode.com/problems/combination-sum-ii/

Code:

class Solution {
    public List<List<Integer>> combinationSum2(int[] cand, int tar) {
        Arrays.sort(cand);
        List<List<Integer>>ans=new ArrayList<>();
        solve(0,tar,cand,ans,new ArrayList<>());
        return ans;
    }
    public void solve(int ind,int tar,int[]cand,List<List<Integer>>ans,ArrayList<Integer>temp){
        if(tar==0){
            ans.add(new ArrayList<>(temp));
            return;
        }

        for(int i=ind;i<cand.length;i++){
            if(i!=ind && cand[i]==cand[i-1]) continue;
            if(cand[i]>tar) break;

            temp.add(cand[i]);
            solve(i+1,tar-cand[i],cand,ans,temp);
            temp.remove(temp.size()-1);
        }
    }    
}


-----------------------------------------------------------------------------------------------------------------------------
Problem No:51

Link:https://leetcode.com/problems/first-missing-positive/

Code:

class Solution {
    public int firstMissingPositive(int[] nums) {
        Arrays.sort(nums);
        int c=1;
        for(int x:nums){
            if(c==x){
                c++;
            }
        }
        return c;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:52

Link:https://leetcode.com/problems/trapping-rain-water/

Code:

class Solution {
    public int trap(int[] arr) {
        int n = arr.length;
        int[] ltr =new int[n];
        int[] rtl = new int[n];
        ltr[0] = arr[0];
        rtl[n-1] = arr[n-1];

        for(int i =1;i<n;i++){
            ltr[i] = Math.max(arr[i],ltr[i-1]);
        }

        for(int i =n-2;i>=0;i--){
            rtl[i] = Math.max(arr[i],rtl[i+1]); 
        }

        int count =0;

        for(int i =0;i<n;i++){
            int min = Math.min(ltr[i],rtl[i]);
            count += ((min-arr[i])>0) ? (min-arr[i]) : 0;
        }

        return count;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:53

Link:https://leetcode.com/problems/multiply-strings/

Code:

import java.math.BigInteger;
class Solution {
    public String multiply(String num1, String num2) {
        BigInteger a = new BigInteger(num1);
        BigInteger b = new BigInteger(num2);
        BigInteger x = a.multiply(b);
        String c=String.valueOf(x);
        return c;

    }
}
-----------------------------------------------------------------------------------------------------------------------------
Problem No:54

Link:https://leetcode.com/problems/wildcard-matching/

Code:

class Solution {
    public boolean isMatch(String s, String p) 
    {
        if(s==null || p==null)
            return s.equals(p);
        
        int m= s.length();
        int n= p.length();
        
        boolean[][] dp = new boolean[m+1][n+1];
        
        dp[0][0] = true;
        
        for(int i=0; i< n ;i++)
        {
            if(p.charAt(i) == '*')
                dp[0][i+1] = dp[0][i];
        }
        
        for(int i=1; i<m+1; i++)
        {
            for(int j=1; j<n+1; j++)
            {
                if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '?')
                    dp[i][j] = dp[i-1][j-1];
                
                else if(p.charAt(j-1) == '*')
                    dp[i][j] = dp[i-1][j] || dp[i][j-1];
            }
        }
        
        return dp[m][n];
        
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:55

Link:https://leetcode.com/problems/jump-game-ii/

Code:

class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int jumps = 0;
        int curEnd = 0;
        int curFarthest = 0;
        for (int i = 0; i < n - 1; i++) {
            curFarthest = Math.max(curFarthest, i + nums[i]);
            if (i == curEnd) {
                jumps++;
                curEnd = curFarthest;
            }
        }
        return jumps;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:56

Link:

Code:

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> listt = new ArrayList<>();

        permutation(nums, 0, listt);
        return listt;
    }

    public void permutation(int[] nums, int ind, List<List<Integer>> listt) {
         List<Integer> ans = new ArrayList<>();
        if (nums.length == ind) {
            for (int num : nums) {
                ans.add(num);
            }
             // We have generated a full permutation, so print it
            listt.add(ans);  
            return;
        }
             // Generate permutations by swapping the current element with each subsequent element
        for (int i = ind; i < nums.length; i++) {
            int temp = nums[ind];
            nums[ind] = nums[i];
            nums[i] = temp;
            permutation(nums, ind + 1, listt);
            nums[i] = nums[ind];
            nums[ind] = temp;
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:57

Link:https://leetcode.com/problems/permutations-ii/

Code:

class Solution {
    int N;
    List<List<Integer>> result;
    public List<List<Integer>> permuteUnique(int[] nums) {
        result = new ArrayList<>();
        N = nums.length;
        Arrays.sort(nums);
        helper(nums,new ArrayList<Integer>(),new ArrayList<Integer>());
        return result;
    }
    
    public void helper(int[] nums,List<Integer> init,List<Integer> cons){
        if(init.size() == N){
            result.add(new ArrayList<Integer>(init));
        }
        
        for(int i=0;i<N;i++){
            if(!cons.contains(i)){
                init.add(nums[i]);
                cons.add(i);
                helper(nums,init,cons);
                init.remove(init.size()-1);
                cons.remove(cons.size()-1);
                while(i<N-1 && nums[i] == nums[i+1]){
                        i++;
                }
            }
        }
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:58

Link:https://leetcode.com/problems/rotate-image/

Code:

class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
        int t[][]=new int[n][n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                t[i][j]=matrix[n-1-j][i];
            }
        }
         for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                matrix[i][j]=t[i][j];
            }
         }
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:59

Link:https://leetcode.com/problems/group-anagrams/

Code:

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String,List<String>> map=new HashMap<>();
        
        for(int i=0;i<strs.length;i++){
            String s1=strs[i];
            char[] arr=s1.toCharArray();
            Arrays.sort(arr);
            String str=new String(arr);
            
            if(map.containsKey(str)){
                map.get(str).add(s1); 
            }else{
                map.put(str,new ArrayList<>());
                map.get(str).add(s1);
            }
        }
        return new ArrayList<>(map.values());
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:60

Link:https://leetcode.com/problems/powx-n/

Code:

class Solution {
    public double myPow(double x, int n) {
        if(n<0){
            n=-n;
            x=1/x;
        }
        double pow=1;
        while(n!=0){
            if((n&1)!=0){
                pow*=x;
            } 
            x*=x;
            n>>>=1;
        }       
        return pow;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:61

Link:https://leetcode.com/problems/n-queens/

Code:

class Solution {
    public List<List<String>> solveNQueens(int n) {
        char[][]board=new char[n][n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                board[i][j]='.';
            }
        }
        List<List<String>>ans=new ArrayList<>();
        
        int leftrow[]=new int[n];
        int upperDiagonal[]=new int[2*n-1];
        int lowerDiagonal[]=new int[2*n-1];

        solve(0,ans,board,leftrow,upperDiagonal,lowerDiagonal);
        return ans;
    }

    public void solve(int col,List<List<String>>ans,char[][]board,int leftrow[],int upperDiagonal[],int lowerDiagonal[]){
        if(col==board.length){
            ans.add(construct(board));//adding the constructed list in a list of list.
            return;
        }

        for(int row=0;row<board.length;row++){
            if(leftrow[row]==0 && upperDiagonal[board.length-1+col-row]==0 && lowerDiagonal[row+col]==0){
                board[row][col]='Q';
                leftrow[row]=1;
                upperDiagonal[board.length-1+col-row]=1;
                lowerDiagonal[row+col]=1;
                solve(col+1,ans,board,leftrow,upperDiagonal,lowerDiagonal);//recursion call

                //for backtrack
                board[row][col]='.';
                leftrow[row]=0;
                upperDiagonal[board.length-1+col-row]=0;
                lowerDiagonal[row+col]=0;
            }
        }
    }

    //construct the string from every row and add them in a list;
    public List<String> construct(char [][] board){
        List<String>cur=new ArrayList<>();
        for(int i=0;i<board.length;i++){
            String str=new String(board[i]);
            cur.add(str);
        }
        return cur;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:62

Link:https://leetcode.com/problems/n-queens-ii/

Code:

class Solution {
public int totalNQueens(int n) {
  boolean[][] board = new boolean[n][n];
  return queens(board,0);
    
}
int queens(boolean[][] board,int row)
{
	if(row==board.length){
        return 1;
    }
    
    int count = 0;
    // Placing Queens and Checking for every row and column
    for(int col=0;col<board.length;col++){
        //place queen if Safe
        if(isSafe(board,row,col)){
            board[row][col] = true;
            count += queens(board,row+1); //Recursive call
            board[row][col] = false;    // Backtrack
        }
    }
    return count;
}

boolean isSafe(boolean[][] board, int row ,int col){
    
    // Vertical row
    for(int i=0;i<row;i++){
        if(board[i][col])
            return false;
    }
    
    // Left diagonal
    int maxLeft = Math.min(row,col);
    for(int i=1;i<=maxLeft;i++){
        if(board[row-i][col-i]){
            return false;
        }
    }
    
    // Right diagonal
    int maxRight = Math.min(row,board.length-col-1);
    for(int i=1;i<=maxRight;i++){
        if(board[row-i][col+i]){
            return false;
        }
    }
    return true;
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:63

Link:https://leetcode.com/problems/maximum-subarray/

Code:

class Solution {
    public int maxSubArray(int[] nums) {
        int msf=nums[0];
        int meh=0;
        for(int i=0;i<nums.length;i++){
            meh=meh+nums[i];
            if(msf<meh){
                msf=meh;
            }
            if(meh<0){
                meh=0;
            }
        }
        return msf;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:64

Link:https://leetcode.com/problems/spiral-matrix/

Code:

public class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        
        List<Integer> res = new ArrayList<Integer>();
        
        if (matrix.length == 0) {
            return res;
        }
        
        int rowBegin = 0;
        int rowEnd = matrix.length-1;
        int colBegin = 0;
        int colEnd = matrix[0].length - 1;
        
        while (rowBegin <= rowEnd && colBegin <= colEnd) {
            // Traverse Right
            for (int j = colBegin; j <= colEnd; j ++) {
                res.add(matrix[rowBegin][j]);
            }
            rowBegin++;
            
            // Traverse Down
            for (int j = rowBegin; j <= rowEnd; j ++) {
                res.add(matrix[j][colEnd]);
            }
            colEnd--;
            
            if (rowBegin <= rowEnd) {
                // Traverse Left
                for (int j = colEnd; j >= colBegin; j --) {
                    res.add(matrix[rowEnd][j]);
                }
            }
            rowEnd--;
            
            if (colBegin <= colEnd) {
                // Traver Up
                for (int j = rowEnd; j >= rowBegin; j --) {
                    res.add(matrix[j][colBegin]);
                }
            }
            colBegin ++;
        }
        
        return res;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:65

Link:https://leetcode.com/problems/jump-game/

Code:

class Solution {
    public boolean canJump(int[] arr) {
        if(arr.length <= 1){
            return true;
        }
        int steps = arr[0];
        int index = 1;
        while(steps > 0){
            if (index == arr.length-1){
                return true;
            }
            steps = Math.max(steps-1, arr[index]);
            index++;
        }
        return false;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:66

Link:https://leetcode.com/problems/merge-intervals/

Code:

class Solution {
    public int[][] merge(int[][] arr) {
         List<int[]> result = new ArrayList<>();

        if(arr.length == 0 || arr == null){
        return result.toArray(new int[0][]);
        }
        Arrays.sort(arr,(a,b)-> a[0]-b[0]);
        int start = arr[0][0];
        int end = arr[0][1];
        for(int[] i : arr){
            if(i[0] <= end){
                end = Math.max(end,i[1]);
            }else{
                result.add(new int[]{start,end});
                start = i[0];
                end = i[1];
            }
        }
        result.add(new int[]{start,end});
        return result.toArray(new int[0][]);
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:67

Link:https://leetcode.com/problems/insert-interval/

Code:

class Solution {
    public int[][] insert(int[][] old, int[] latest) {

       ArrayList<int[]> list = new ArrayList<>();
        for(int i = 0 ; i < old.length ; i++){
            if(old[i][1] < latest[0]) list.add(old[i]);
            else if(old[i][0] > latest[1]) {
                list.add(latest);
                latest = old[i];
                }

            else{
                latest[0] = Math.min(old[i][0] , latest[0]);
                latest[1] = Math.max(old[i][1], latest[1]);
            }
        }
        list.add(latest);
        int ans[][]  = new int[list.size()][2];

        for(int i = 0; i < list.size() ; i++){
            ans[i] = list.get(i);
        }
        return ans;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:68

Link:https://leetcode.com/problems/length-of-last-word/

Code:

class Solution {
    public int lengthOfLastWord(String s) {
        int n=s.length();
        int c=0;
        for(int i=n-1;i>=0;i--){
            if(s.charAt(i)!=' '){ 
                c+=1;
            }
            if(c!=0 && s.charAt(i)==' '){
                break;
            }
        }
        return c;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:69

Link:https://leetcode.com/problems/spiral-matrix-ii/

Code:

class Solution {
    public int[][] generateMatrix(int n) {
       int[][] ans=new int[n][n];
       
        int rowBegin=0;
        int rowEnd=n-1;
        int colBegin=0;
        int colEnd=n-1;
        int counter=0;
      
        while(rowBegin<=rowEnd && colBegin<=colEnd && counter<=n*n){
            
            for(int i=colBegin;i<=colEnd;i++){
                counter++;
                ans[rowBegin][i]=counter;
            }
            rowBegin++;
            for(int i=rowBegin;i<=rowEnd;i++){
                counter++;
                ans[i][colEnd]=counter;
            }
            colEnd--;
            if(rowBegin<=rowEnd){
                for(int i=colEnd;i>=colBegin;i--){
                counter++;
                ans[rowEnd][i]=counter;
            }
           
            }
             rowEnd--;
            if(colBegin<=colEnd){
                for(int i=rowEnd;i>=rowBegin;i--){
                counter++;    
                ans[i][colBegin]=counter;
            }
            
            }
            colBegin++;
           
        }
        
        return ans;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:70

Link:https://leetcode.com/problems/permutation-sequence/

Code:

class Solution {
    public String getPermutation(int n, int k) {
        int fac = 1;
        List<Integer> al = new ArrayList<>();
        for(int i = 1;i < n; i++){
            fac *= i;
            al.add(i);
        }
        al.add(n);
        String res = "";
        k--;
        while(true){
            res += al.get(k / fac);
            al.remove(k / fac);
            if(al.size() == 0)
                break;
            k %= fac; 
            fac /= al.size();
        }
        return res;
    }   
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:71

Link:https://leetcode.com/problems/rotate-list/

Code:

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (k==0 || head==null) return head;
        int count = 1;
        ListNode temp = head;
        while (temp.next!=null) {
            count++;
            temp = temp.next;
        }
        if (k>count) k = k%count;
        if (k==count) return head;
        k = count-k-1;
        temp.next = head;
        temp = head;
        while (k>0) {
            k--;
            temp = temp.next;
        }
        head = temp.next;
        temp.next = null;
        return head;
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:72

Link:https://leetcode.com/problems/unique-paths/

Code:

class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        return findPath(0, 0, m, n, dp);
    }
    int findPath(int p1, int p2, int m, int n, int[][] dp) {
        if (p1+1==m && p2+1==n) return 1;
        if (p1==m) return 0;
        if (p2==n) return 0;
        if (dp[p1][p2]!=0) return dp[p1][p2];
        dp[p1][p2] = findPath(p1+1, p2, m, n, dp) + findPath(p1, p2+1, m ,n, dp);
        return dp[p1][p2];
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:73

Link:https://leetcode.com/problems/unique-paths-ii/

Code:

class Solution {
    public int uniquePathsWithObstacles(int[][] OG) {
        if (OG[0][0] == 1) return 0;
        int m = OG.length, n = OG[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;
                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);
        return dp[m-1][n-1];
    }
}

-----------------------------------------------------------------------------------------------------------------------------
Problem No:74

Link:https://leetcode.com/problems/minimum-path-sum/

Code:

class Solution {
    public int minPathSum(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        
        for (int i = 1; i < m; i++) {
            matrix[i][0] += matrix[i-1][0];
        }
        
        for (int j = 1; j < n; j++) {
            matrix[0][j] += matrix[0][j-1];
        }
        
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                matrix[i][j] += Math.min(matrix[i-1][j], matrix[i][j-1]);
            }
        }
        
        return matrix[m-1][n-1];
    }
}


-----------------------------------------------------------------------------------------------------------------------------
Problem No:75

Link:https://leetcode.com/problems/valid-number/

Code:

class Solution {
    public boolean isNumber(String s) {
        try{
            int l=s.length();
            if(s.equals("Infinity")||s.equals("-Infinity")||s.equals("+Infinity")||s.charAt(l-1)=='f'||s.charAt(l-1)=='d'||s.charAt(l-1)=='D'||s.charAt(l-1)=='F')
            return false;
            double x=Double.parseDouble(s);
            return true;
        }
        catch(Exception e){
            return false;
        }
        
    }
}

-----------------------------------------------------------------------------------------------------------------------------
